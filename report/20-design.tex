\chapter{Конструкторская часть}

В данном разделе представлены требования к программному обеспечению, а также приведены способы реализации методов и алгоритмов DIA, применимых к решению поставленной задачи.


\section{Требования к программному обеспечению}

Программа должна предоставлять доступ к следующим возможностям:
\begin{enumerate}
	\item чтение, создание, изменение и удаление данных БД;
	\item изменение пользователем параметров запроса (например, с помощью аргументов адресной строки).
\end{enumerate}

К программе предъявляются следующие требования:
\begin{itemize}
	\item программа должна запрещать создавать, изменять, удалять записи из базы данных неаутентифицированным пользователям.
\end{itemize}


\section{Проектирование базы данных}

На основании исследования существующих СУБД было решено использовать реляционную СУБД PostgreSQL, поскольку эта СУБД свободно распространяется и имеет обширную, подробную документацию. В PostgreSQL реализована поддержка языка plpgsql, который упрощает процесс проектирование БД. Кроме того,
в PostgreSQL есть инструмент EXPLAIN, с помощью которого удобно вести разработку оптимизированных запросов (в частности, создания индексов).


База данных должна хранить данные, рассмотренные в таблице 1.1. В соответствии с этой таблицей можно выделить следующие сущности в базе данных:
\begin{itemize}
	\item таблица самолетов \textbf{aircrafts},
	\item таблица аэропортов \textbf{airports},
	\item таблица авиакомпаний \textbf{airlines},
	\item таблица информации о перелетах \textbf{delays}.
\end{itemize}
На рисунке 2.1 приведена ER-диаграмма спроектированной базы данных в нотации Чена \cite{chen}.



\img{120mm}{4}{ER-диаграмма спроектированной БД}


Далее приведены поля выделенных таблиц, их тип в СУБД PostgreSQL \cite{postgres} а также их небольшие описания:
\begin{itemize}
	\item таблица \textbf{aircrafts}:
	\begin{itemize}
		\item tail\_no (PK) - varchar, номер регистрации воздушного судна;
		\item mfr - varchar, наименование производителя;
		\item model - varchar, полное название модели;
		\item bday - date, дата ввода в эксплуатацию;
		\item photo - varchar, URL изображения судна;
	\end{itemize}
	
	\item таблица \textbf{airports}:
	\begin{itemize}
		\item iata (PK) - varchar, номер аэропорта в международной кодировке;
		\item fullname - varchar, полное название аэропорта;
		\item city - varchar, город;
		\item \_state - varchar, штат (область);
		\item country - varchar, страна;
		\item lat - numeric, широта;
		\item lng - numeric, долгота;
	\end{itemize}
	
	\item таблица \textbf{airlines}:
	\begin{itemize}
		\item airline\_id (PK) - varchar, код авиакомпании, состоящий из двух символов;
		\item fullname - varchar, полное название авиакомпании;
		\item addr - varchar, адрес главного офиса;
		\item phone\_no - varchar, контактный номер телефона;
	\end{itemize}
	
	\item таблица \textbf{delays}:
	\begin{itemize}
		\item delay\_id (PK) - serial, уникальный идентификатор записи в таблице;
		\item flight\_date - date, дата совершения перелета;
		\item day\_of\_week - integer, номер дня недели, в который был совершен рейс;
		\item tail\_no (FK) - varchar, номер регистрации воздушного судна;
		\item airline\_id (FK) - varchar, код авиакомпании, состоящий из двух символов;
		\item flight\_id - integer, численный код рейса;
		\item origin (FK) - varchar, номер аэропорта вылета в международной кодировке;
		\item dest (FK) - varchar, номер аэропорта прилета в международной кодировке;
		\item dist - numeric, длина маршрута в милях;
		\item scheduled\_time - time, расчетное время в пути;
		\item real\_time - time, фактическое время в пути;
		\item delayed - bit, флаг, был ли рейс задержан;
		\item diverted - bit, флаг, был ли рейс переведен в другой аэропорт;
		\item cancelled - bit, флаг, был ли рейс отменен.
	\end{itemize}
\end{itemize}




\section{Проектирование DIA-механизмов}

\subsection{Индексы}

Решение о том, какие индексы создать, выносится на основание того, какие будут выполняться, в первую очередь SELECT, запросы. Самым простым, но тем не менее эффективным, решением является создание индексов на primary key (PK) каждой из таблицы. Это оправданное решение, поскольку с помощью инструмента EXPLAIN было установлено, что большинство запросов к БД в разработанной системе выполняют поиск записей именно по PK таблиц. Также было решено создать индекс на поле tail\_no таблицы delays, поскольку это относительно частый ключ поиска записей в таблице информации о выполненных рейсах.

\subsection{Master-Slave репликация}

Для реализации Master-Slave реликациии необходимо иметь несколько машин. Для имитации нескольких хостов на одной машине были использованы linux-конйтенеры (LXC) \cite{lxc}. Всего было создано 3 Slave-реплики с помощью linux-контейнеров.

Настройка реплик подробно рассмотрена в технологическом разделе.

\subsection{Кэширование}

Для реализации кэша запросов была выбрана in-memory key-value СУБД Redis по следующим причинам:
\begin{itemize}
	\item все данные Redis хранятся в памяти, что обеспечивает низкую задержку и высокую пропускную способность доступа к данным;
	\item в Redis реализована поддержка разнообразных структур данных, которые, могут быть применены для реализации кэша, в частности.
\end{itemize}

Чтобы реализовать алгоритм 2Q \cite{2q}, рассмотренный в аналитической части, в хранилище Redis, было принято решение использовать следующие встроенные структуры данных Redis:
\begin{itemize}
	\item list (связанный список) - в качестве <<теплой>> и <<горячей>> очередей.
	\item hash table (хэш-таблица) - для хранения результатов выполнения SQL-запросов.
\end{itemize}

На рисунке 2.2 приведена схема алгоритма 2Q.
\img{150mm}{2}{Схема алгоритма 2Q}

В очереди помещаются захэшированные строки (ключи), представляющие собой SQL-выражение. В соответствующие хэш-таблицы по заданному ключу хранится JSON-строка, содержащая результат выполнения запроса-ключа. Важно постараться исключить коллизии в ключах, поэтому было решено использовать алгоритм SHA-256 \cite{sha256} для хэширования SQL-запросов, поскольку данный алгоритм является детерминированным (для одних и тех же запросов он вернет одинаковый хэш), а также возвращает хэши одного размера (256 бит). Отметим, что на сегодняшний день не было найдено коллизий хэшей SHA-256.

Очереди отличаются по размеру: <<теплая>> очередь должна быть длиннее <<горячей>>. Точные размеры очередей подбираются, исходя из размеров сохраняемых данных, объема памяти устройства а также нагрузки на сервер. В рамках данного проекта было принято решение использовать <<горячую>> очередь  длиной в 10 элементов, а <<теплую>> - в 20.

За неимением больших вычислительных кластеров, было принято решение запустить сервер с Redis на том же устройстве, что и Master-реплику.


\section{Проектирование приложения}

\subsection{Структура приложения}

Каждый запрос на чтение, в первую очередь, проверяется, нет ли ответа в кэше. Если запрос не был закэширован, тогда запрос поступает на одну из реплик: благодаря хэшированию запроса алгоритмом SHA-256, а затем взятию от полученного числа модуля, равного количеству реплик, нагрузка между репликами будет балансироваться равномерно.
Запросы на изменение обрабатывает только Master-реплика. Изменения распространяются на Slave-реплики с задержкой в 10 минут. Это сделано для того, чтобы в случае возникновения чрезвычайной ситуации (например, случайного удаления всей БД), можно было успеть созранить данные на репликах, сделаd одну из нод мастером.

Чтобы выполнить изменение данных, в теле HTTP-запроса необходимо передать токен аутентификации. Если переданный токен не зарегистрирован в системе, то пользователю запрещается вносить изменения.


На рисунке 2.3 приведена схема структуры разработанного приложения.
\img{170mm}{5}{Структура разработанного приложения}

\subsection{Ролевая модель}

В случае, если по какой-то причине откажет Master, то необходимо повысить одну из Slave-реплик до Master, а старый Master, после починки, сделать Slave. Поскольку пул адресов хостов с БД остается неизменным, но роли реплик могут меняться с течением времени, удобно ввести ролевую модель на уровне БД.

Было реализовано две роли:
\begin{itemize}
	\item postgres - суперпользователь, имеющий все привилегии в БД;
	\item guest - пользователь, для которого не требуется аутентификация токеном, для него разрешено только чтение данных.
\end{itemize}.

Таким образом, подключение для чтения данных будет осуществляться под ролью guest к любой из реплик, в то время как для создания, удаления, изменения данных - пользователь postgres к Master-реплике. 


\section*{Вывод}

На основании выделенных сущностный, было принято решение создать 4 таблицы в базе данных: aircrafts, airports, airlines и delays. Выбранная СУБД - PostgreSQL.

Было решено использовать следующие методы и механизмы DIA:
\begin{itemize}
	\item создать индексы было решено для PK таблиц БД, а так же для поля tail\_no таблицы delays;
	\item lxc-контейнеры для создания Slave-реплик БД: всего было создано 3 Slave-реплики;
	\item для реализации алгоритма кэширования 2Q решено использовать встроенные структуры данных Redis: связанные списки и хэш-таблицы. Для генерации ключа-хэша используется алгоритм SHA-256.
\end{itemize}

В спроектированном приложении были выделены две роли на уровне БД: postgres (с правами на чтение и изменение данных) и guest (с правами только на чтение).